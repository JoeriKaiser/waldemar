---
import { Image } from "astro:assets";
import base from "../../assets/images/base.png";
---

<section class="jumbo" data-jumbo-root>
  <div class="jumbo-grid">
    <!-- Text Content -->
    <div class="jumbo-content">
      <div class="intro-stamps">
        <span class="stamp" data-stamp>Dev since 2022</span>
        <span class="stamp stamp-olive" data-stamp>NL â†’ FR</span>
      </div>

      <h1 class="jumbo-title" data-hero-text>
        <span class="title-line">Hello, I'm</span>
        <span class="title-name">Joeri</span>
      </h1>

      <p class="jumbo-tagline" data-hero-text>
        Building applications that work <em>reliably</em> and feel <em>great</em>
      </p>

      <p class="jumbo-description" data-hero-text>
        A full-stack developer focused on solid architecture and smooth experiences.
        Former bartender, always curious.
      </p>

      <div class="jumbo-actions" data-hero-text>
        <a href="#projects-list-start" class="btn btn-primary" data-magnetic>
          View my work
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 5v14M19 12l-7 7-7-7"/>
          </svg>
        </a>
        <button id="open-cmdk" class="btn btn-ghost" data-magnetic>
          Quick open
          <kbd class="kbd">K</kbd>
        </button>
      </div>
    </div>

    <!-- Portrait -->
    <div class="jumbo-portrait">
      <div class="portrait-frame" data-tilt-container>
        <!-- Decorative tape elements -->
        <div class="tape tape-top" aria-hidden="true"></div>
        <div class="tape tape-bottom" aria-hidden="true"></div>

        <div class="portrait-inner" data-portrait>
          <!-- Real image (revealed) -->
          <Image
            src={base}
            alt="Portrait of Joeri"
            class="portrait-image portrait-real"
            loading="eager"
          />
          <!-- Filtered overlay (scratched away) -->
          <canvas class="scratch-canvas" data-scratch-canvas></canvas>
        </div>

        <!-- Corner decorations -->
        <div class="corner-deco corner-tl" aria-hidden="true"></div>
        <div class="corner-deco corner-br" aria-hidden="true"></div>
      </div>

      <div class="portrait-caption">
        <span class="caption-text">Coding with care since 2022</span>
      </div>
    </div>
  </div>
</section>

<script>
  document.addEventListener("astro:page-load", async () => {
    const root = document.querySelector("[data-jumbo-root]");
    if (!root) return;

    const prefersReduced = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
    const tiltContainer = root.querySelector("[data-tilt-container]");
    const portrait = root.querySelector("[data-portrait]");
    const cmdk = root.querySelector("#open-cmdk");
    const canvas = root.querySelector("[data-scratch-canvas]") as HTMLCanvasElement | null;
    const realImage = root.querySelector(".portrait-real") as HTMLImageElement | null;

    cmdk?.addEventListener("click", () =>
      window.dispatchEvent(new CustomEvent("open-command-palette"))
    );

    // Scratch reveal effect
    if (canvas && realImage && portrait) {
      const ctx = canvas.getContext("2d");
      if (!ctx) return;

      let isDrawing = false;
      let scratchedPixels = 0;
      const revealThreshold = 0.25; // Reveal fully after 25% scratched

      const setupCanvas = () => {
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);

        // Draw the filtered version of the image
        ctx.filter = "sepia(0.08) saturate(0.95)";
        ctx.drawImage(realImage, 0, 0, rect.width, rect.height);
        ctx.filter = "none";

        // Add slight paper texture overlay
        ctx.globalCompositeOperation = "overlay";
        ctx.fillStyle = "rgba(250, 246, 241, 0.15)";
        ctx.fillRect(0, 0, rect.width, rect.height);
        ctx.globalCompositeOperation = "source-over";
      };

      // Wait for image to load
      if (realImage.complete) {
        setupCanvas();
      } else {
        realImage.addEventListener("load", setupCanvas);
      }

      const scratch = (x: number, y: number) => {
        const rect = canvas.getBoundingClientRect();
        const canvasX = x - rect.left;
        const canvasY = y - rect.top;

        ctx.globalCompositeOperation = "destination-out";
        ctx.beginPath();
        ctx.arc(canvasX, canvasY, 25, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalCompositeOperation = "source-over";

        scratchedPixels += Math.PI * 25 * 25;
        const totalPixels = rect.width * rect.height;

        if (scratchedPixels / totalPixels > revealThreshold) {
          portrait.classList.add("revealed");
        }
      };

      const onStart = (e: PointerEvent) => {
        isDrawing = true;
        scratch(e.clientX, e.clientY);
      };

      const onMove = (e: PointerEvent) => {
        if (!isDrawing) return;
        scratch(e.clientX, e.clientY);
      };

      const onEnd = () => {
        isDrawing = false;
      };

      canvas.addEventListener("pointerdown", onStart);
      canvas.addEventListener("pointermove", onMove);
      canvas.addEventListener("pointerup", onEnd);
      canvas.addEventListener("pointerleave", onEnd);

      // Reset on window resize
      let resizeTimeout: ReturnType<typeof setTimeout>;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          scratchedPixels = 0;
          portrait.classList.remove("revealed");
          setupCanvas();
        }, 200);
      });
    }

    if (!prefersReduced) {
      const { gsap } = await import("gsap");

      // Entrance animations
      const stamps = root.querySelectorAll("[data-stamp]");
      const heroText = root.querySelectorAll("[data-hero-text]");
      const portraitFrame = root.querySelector(".portrait-frame");

      const tl = gsap.timeline({ defaults: { ease: "power2.out" } });

      // Portrait grows in with slight rotation
      if (portraitFrame) {
        tl.from(portraitFrame, {
          scale: 0.9,
          rotation: -5,
          opacity: 0,
          duration: 0.7,
        });
      }

      // Stamps animate in with "stamp" effect
      if (stamps.length) {
        tl.from(
          stamps,
          {
            scale: 1.3,
            rotation: -8,
            opacity: 0,
            duration: 0.4,
            stagger: 0.15,
            ease: "back.out(1.7)",
          },
          "-=0.3"
        );
      }

      // Text staggers in
      if (heroText.length) {
        tl.from(
          heroText,
          {
            y: 20,
            opacity: 0,
            stagger: 0.1,
            duration: 0.5,
          },
          "-=0.2"
        );
      }

      // Subtle tilt effect on portrait
      if (tiltContainer instanceof HTMLElement && portrait instanceof HTMLElement) {
        let rx = 0,
          ry = 0,
          raf = 0;

        const apply = () => {
          raf = 0;
          portrait.style.transform = `rotateX(${rx}deg) rotateY(${ry}deg) translateZ(0)`;
        };

        const onMove = (e: PointerEvent) => {
          const r = tiltContainer.getBoundingClientRect();
          const cx = r.left + r.width / 2;
          const cy = r.top + r.height / 2;

          const x = (e.clientX - cx) / (r.width / 2);
          const y = (e.clientY - cy) / (r.height / 2);
          const max = 6; // Subtle tilt

          ry = x * max;
          rx = -y * max;
          if (!raf) raf = requestAnimationFrame(apply);
        };

        const onLeave = () => {
          rx = 0;
          ry = 0;
          portrait.style.transition = "transform 300ms ease-out";
          portrait.style.transform = "rotateX(0deg) rotateY(0deg) translateZ(0)";
          setTimeout(() => (portrait.style.transition = ""), 320);
        };

        tiltContainer.addEventListener("pointermove", onMove);
        tiltContainer.addEventListener("pointerleave", onLeave);
      }
    }

    // Magnetic buttons
    const magneticButtons = root.querySelectorAll("[data-magnetic]");
    if (!prefersReduced && magneticButtons.length) {
      const { gsap } = await import("gsap");
      magneticButtons.forEach((btn) => {
        if (!(btn instanceof HTMLElement)) return;
        btn.addEventListener("mouseenter", () =>
          gsap.to(btn, { scale: 1.03, duration: 0.25, ease: "power2.out" })
        );
        btn.addEventListener("mouseleave", () =>
          gsap.to(btn, { scale: 1, x: 0, y: 0, duration: 0.25, ease: "power2.out" })
        );
        btn.addEventListener("mousemove", (e) => {
          const r = btn.getBoundingClientRect();
          const x = (e.clientX - (r.left + r.width / 2)) / 12;
          const y = (e.clientY - (r.top + r.height / 2)) / 12;
          gsap.to(btn, { x, y, duration: 0.3, ease: "power2.out" });
        });
      });
    }
  });
</script>

<style>
  .jumbo {
    width: 100%;
    padding: var(--space-xl) 0;
    min-height: clamp(500px, 70vh, 800px);
    display: flex;
    align-items: center;
  }

  .jumbo-grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: var(--space-xl);
    align-items: center;
    max-width: 1100px;
    margin: 0 auto;
    padding: 0 var(--space-l);
  }

  @media (min-width: 768px) {
    .jumbo-grid {
      grid-template-columns: 1.1fr 0.9fr;
    }
  }

  /* Content Section */
  .jumbo-content {
    display: flex;
    flex-direction: column;
    gap: var(--space-m);
    order: 2;
  }

  @media (min-width: 768px) {
    .jumbo-content {
      order: 1;
    }
  }

  .intro-stamps {
    display: flex;
    flex-wrap: wrap;
    gap: var(--space-xs);
  }

  .jumbo-title {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    transform: rotate(-1deg);
  }

  .title-line {
    font-family: var(--font-body);
    font-size: var(--text-body);
    font-weight: 500;
    color: var(--wc-bark);
    letter-spacing: var(--tracking-wide);
    text-transform: uppercase;
  }

  .title-name {
    font-family: var(--font-display);
    font-size: var(--text-hero);
    font-weight: 600;
    color: var(--wc-ink);
    line-height: var(--leading-display);
  }

  .jumbo-tagline {
    font-family: var(--font-display);
    font-size: var(--text-h2);
    font-weight: 400;
    color: var(--wc-espresso);
    line-height: var(--leading-heading);
  }

  .jumbo-tagline em {
    font-style: normal;
    color: var(--wc-accent);
    position: relative;
  }

  .jumbo-tagline em::after {
    content: "";
    position: absolute;
    left: 0;
    right: 0;
    bottom: 2px;
    height: 3px;
    background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 4'%3E%3Cpath d='M0 2 Q5 0 10 2 T20 2' stroke='%23e8c4b4' stroke-width='2' fill='none'/%3E%3C/svg%3E") repeat-x;
    background-size: 20px 4px;
  }

  .jumbo-description {
    font-size: var(--text-body);
    color: var(--wc-bark);
    line-height: var(--leading-body);
    max-width: 480px;
  }

  .jumbo-actions {
    display: flex;
    flex-wrap: wrap;
    gap: var(--space-s);
    padding-top: var(--space-xs);
  }

  /* Portrait Section */
  .jumbo-portrait {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: var(--space-s);
    order: 1;
  }

  @media (min-width: 768px) {
    .jumbo-portrait {
      order: 2;
    }
  }

  .portrait-frame {
    position: relative;
    width: clamp(260px, 50vw, 340px);
    aspect-ratio: 1;
    background: var(--wc-cream);
    border: 3px solid var(--wc-olive);
    border-radius: var(--radius-lg);
    padding: 12px;
    box-shadow: var(--shadow-lg);
    transform: rotate(2deg);
    transition:
      transform var(--duration-normal) var(--ease-bounce),
      box-shadow var(--duration-normal) var(--ease-smooth);
  }

  .portrait-frame:hover {
    transform: rotate(0deg) scale(1.02);
    box-shadow: var(--shadow-xl);
  }

  /* Separate container for 3D tilt effect */
  .portrait-tilt-wrapper {
    width: 100%;
    height: 100%;
    perspective: 800px;
    transform-style: preserve-3d;
  }

  .portrait-inner {
    position: relative;
    width: 100%;
    height: 100%;
    border-radius: var(--radius-md);
    overflow: hidden;
    background: var(--wc-sand);
    transform-style: preserve-3d;
    will-change: transform;
  }

  .portrait-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .portrait-real {
    position: absolute;
    inset: 0;
  }

  .scratch-canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    cursor: crosshair;
    touch-action: none;
  }

  .portrait-inner.revealed .scratch-canvas {
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.5s ease-out;
  }

  /* Decorative tape */
  .tape {
    position: absolute;
    width: 50px;
    height: 18px;
    background: var(--wc-accent-muted);
    opacity: 0.85;
    z-index: 10;
  }

  .tape-top {
    top: -8px;
    left: 50%;
    transform: translateX(-50%) rotate(-8deg);
    border-radius: 2px;
  }

  .tape-bottom {
    bottom: -8px;
    right: 20%;
    transform: rotate(5deg);
    border-radius: 2px;
    background: var(--wc-olive-soft);
  }

  /* Corner decorations */
  .corner-deco {
    position: absolute;
    width: 24px;
    height: 24px;
    border: 2px solid var(--wc-accent);
    opacity: 0.4;
  }

  .corner-tl {
    top: -6px;
    left: -6px;
    border-right: none;
    border-bottom: none;
    border-radius: 4px 0 0 0;
  }

  .corner-br {
    bottom: -6px;
    right: -6px;
    border-left: none;
    border-top: none;
    border-radius: 0 0 4px 0;
  }

  .portrait-caption {
    text-align: center;
  }

  .caption-text {
    font-family: var(--font-display);
    font-size: var(--text-small);
    font-style: italic;
    color: var(--wc-bark);
    opacity: 0.7;
  }

  /* Responsive adjustments */
  @media (max-width: 767px) {
    .jumbo {
      padding-top: var(--space-l);
    }

    .jumbo-title {
      text-align: center;
      transform: rotate(0deg);
    }

    .jumbo-tagline,
    .jumbo-description {
      text-align: center;
    }

    .jumbo-actions {
      justify-content: center;
    }

    .intro-stamps {
      justify-content: center;
    }
  }
</style>
